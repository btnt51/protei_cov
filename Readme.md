# Protei_cov
---
Это курсовой проект в рамках подготовки к прохождению стажировкии в НТЦ Протей.
Необходимо реализовать настраиваемый сервер - центр обработки вызовов, который будет реагировать на http запросы, 
которые в свою очередь эмулируют "входящий вызов".  
Для каждого такого запроса необходимо генерировать уникальный идентификатор (CallID), 
который используется в журналах вызывов (CDR).

---

## Используемые технологи:
Логгер:
SPDLOG с автоматическим скачиванием и сборкой при сборке основного проекта.

Тесты:
GTests с автоматическим скачиванием и сборкой при сборке тестов.

Сеть:
Boost

## Общепринятая терминология в рамках проекта
- ЦОВ - Центр Обработки Вызовов
- Абонент А, он же CgPN - вызывающий абонент, инициатор вызова
- Абонент Б, он же CdPN - вызываемый абонент
- ПАК - программно-аппаратный комплекс
- РМО - рабочее место оператора, ПАК, который обычно состоит из компьютера, установленного на него специального ПО, а также оборудование для обработки медиа (гарнитура + веб-камера)
- Call - вызов, обычно голосовой вызов
- Call ID - идентификатор вызова, как правило строка, уникальное значение, желательно чтобы это было значение сохраняющее свойство уникальности в течении длительного периода времени и для всего комплекса ПО
- Release - отбой, завершение вызова
- Release Cause - причина отбоя, причина завершения обработки вызова. Есть на самом деле стандарты, где описываются все стандартные предусмотренные причины отбоя, например Q.850
- CDR - Call Detailed Record, информационная запись в журнале по факту предоставления услуги. Обычно это текстовый файл, журнал, имеет фиксированное количество полей разделенных каким-то символом (у нас чаще всего это точка с запятой “;”)


## Как пользоваться программой:
Можно скачать последнюю версию программы из github releases, предоставляется две версии:
- Для Debian based дистрибутивов на x64
- Для Debian based диструбитивов на arm64

Также можно склонировать репозиторий себе на персональный компьютер и собрать вручную, 
для этого требуется установленный cmake не ниже версии 3.12 и любой компилятор (тестировалось, собиралось и соибрается
gcc 13.2). Далее представлена команда для сборки, но со сборкой тестов, чтобы не билдить тесты
необходимо изменить команду -D WITH_TESTS=ON. По-умолчанию, CMake ищет spdlog и boost в вашей системе, 
если их нет в системе, cmake сам все скачает и может скачать в двух вариантах - тяжелое (весь буст) или легкий,
только конкретные библиотеки. Для второго варианта в аргументах cmake нужно указать -D LIGHTWEIGHTBABY=ON.
```shell
git clone https://github.com/btnt51/protei_cov.git
cd protei_cov
mkdir build && cd build
cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXPORT_COMPILE_COMMANDS=1 -D WITH_TESTS=ON -D LIGHTWEIGHTBABY=NO ..
```
Можно запускать по-умолчанию:
```shell
./protei_cov
```

Можно указать порт (стандартный порт 8080) и путь до файла (стандартный путь до файла ./base.json)
```shell
./protei_cov <порт> <путь_до_файла>
```

## Нагрузочное тестирование
Можно произвести нагрузочное тестирование для этого необходимо склонировать репозиторий и 
иметь установленный python3 в системе.
Необходимо в двух терминалах запустить тест и программу

Первый терминал с тестом. В нем можно указать размер отправленной пачки сообщений в моменте, 
по-умолчанию отправится всё что есть, например --num_connections 300, 
а также режим - автоматический (--automatic) или ручной (не надо ничего указывать)
```shell
cd protei_cov
python3 tools/load.py <аргументы>
```
Во втором терминале необходимо запустить на дефолтном порту.
```shell
./protei_cov 8080
```

Теперь можно наблюдать за работой сервера под нагрузкой.


## Обновление конфигурации
Сервер умеет обновлять конфигурацию во время своей работы, для этого он использует путь до .json файла,
который был указан при запуске сервера. Этот файл можно менять руками, перечитывание файла происходит каждую минуту, 
при условии, что файл был изменен (проверятся последнее время записи в файл).

А также можно принудительно заставить сервер обновиться. Для этого требуется отправить http get запрос, 
на соответствующий url /update (например вы запускаете локально сервер на порту 8080, тогда требуется отправить запрос
на адрес localhost:8080/update).